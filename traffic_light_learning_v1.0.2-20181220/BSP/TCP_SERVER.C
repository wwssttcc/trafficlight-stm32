#include "main.h"

/***********************************************************************
函数名称：tcp_server_recv(void *arg, struct tcp_pcb *pcb,struct pbuf *p,err_t err)
功    能：TCP数据接收和发送
注    意：这是一个回调函数，当一个TCP段到达这个连接时会被调用
***********************************************************************/
struct tcp_pcb *g_pcb[3];
char g_accept_num = 0;
uint16_t g_tcp_num[3];
static err_t tcp_server_recv(void *arg, struct tcp_pcb *pcb,struct pbuf *p,err_t err)
{
	char i;
	struct pbuf *p_temp = p;
	
	if(p_temp != NULL)
	{	
		tcp_recved(pcb, p_temp->tot_len);//获取数据长度 tot_len：tcp数据块的长度
		while(p_temp != NULL)	
		{				
			for(i = 0; i < 3; i++)
			{
				if(pcb == g_pcb[i])
				{
					g_tcp_num[i] = 0;
					break;
				}
			}
			/******将数据原样返回*******************/
			tcp_write(pcb,p_temp->payload,p_temp->len,TCP_WRITE_FLAG_COPY); 	// payload为TCP数据块的起始位置       
			tcp_output(pcb);
			p_temp = p_temp->next;
		}		
	}
	else
	{
		tcp_close(pcb); 											/* 作为TCP服务器不应主动关闭这个连接？ */
	}
	/* 释放该TCP段 */
	pbuf_free(p); 	
	err = ERR_OK;
	return err;
}

/***********************************************************************
函数名称：tcp_server_accept(void *arg, struct tcp_pcb *pcb,struct pbuf *p,err_t err)
功    能：回调函数
注    意：这是一个回调函数，当一个连接已经接受时会被调用
***********************************************************************/
static err_t tcp_server_accept(void *arg,struct tcp_pcb *pcb,err_t err)
{
	char i;
		
		if(g_accept_num > 2)
		{
			info_msg("当前%d连接\r\n", g_accept_num);
			return -1;
		}
		for(i = 0; i < 3; i++)
		{
			if(g_pcb[i] == NULL)
			{
				g_pcb[i] = pcb;
				break;
			}
		}
	g_accept_num++;
	tcp_setprio(pcb, TCP_PRIO_MIN); 		/* 设置回调函数优先级，当存在几个连接时特别重要,此函数必须调用*/
	tcp_recv(pcb,tcp_server_recv); 				/* 设置TCP段到时的回调函数 */
	err = ERR_OK;
	return err;
}


/***********************************************************************
函数名称：TCP_server_init(void)
功    能：完成TCP服务器的初始化，主要是使得TCP通讯快进入监听状态

***********************************************************************/

void TCP_server_init(void)
{
	struct tcp_pcb *pcb;
	char i;
	/*****************************************************/
	for(i = 0; i < 3; i++)
	{
		g_pcb[i] = NULL;
		g_tcp_num[i] = 0;
	}
	pcb = tcp_new(); 								/* 建立通信的TCP控制块(pcb) */
	tcp_bind(pcb,IP_ADDR_ANY,TCP_SERVER_PORT); 	    /* 绑定本地IP地址和端口号（作为tcp服务器） */
	pcb = tcp_listen(pcb); 							/* 进入监听状态 */
	tcp_accept(pcb,tcp_server_accept); 			    /* 设置有连接请求时的回调函数 */
}
